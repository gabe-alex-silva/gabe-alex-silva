#FULL simulation example and three part code with Grover THEN (classical) binary subtraction to evlauate f(s_i) THEN the 2 run DJ
#See https://arxiv.org/abs/2403.18963 for the asscoiated reseaerch paper to this code and the notation used and full theoretical development

#Gabriel A. Silva
#University of California San Diego
#gsilva@ucsd.edu

!pip install --quiet cirq
!pip install --quiet qsimcirq

import cirq
import qsimcirq
import numpy as np
from collections import Counter


################################################
#Grover Setup - Membership determination in S_n

def build_grover_marking(data_qubits, ancilla, S_n):
    """
    Marking circuit (oracle) for Grover:
    - data_qubits: 7 qubits for the search space
    - ancilla: 1 additional qubit (the target of multi-controlled Z)
    - S_n: a list/set of integers in [0..127] to be phase-flipped
    """
    circuit = cirq.Circuit()
    n = len(data_qubits)  # should be 7
    for x in S_n:
        bin_str = format(x, '0{}b'.format(n))  # e.g. '0101101' for 7 bits
        ops = []
        # Flip '0'-bits so that the desired state is |111...1>
        for i, bit in enumerate(bin_str):
            if bit == '0':
                ops.append(cirq.X(data_qubits[i]))
        # Multi-controlled Z on ancilla, controlled by data_qubits
        # The ancilla is *not* in data_qubits, so no duplication
        ops.append(cirq.Z(ancilla).controlled_by(*data_qubits))
        # Unflip
        for i, bit in enumerate(bin_str):
            if bit == '0':
                ops.append(cirq.X(data_qubits[i]))
        circuit.append(ops)
    return circuit

def build_grover_diffusion(data_qubits):
    """
    Standard Grover diffusion operator on the 7 data qubits (no ancilla).
    1) H^n
    2) X^n
    3) Multi-controlled Z (target is the last data_qubit) 
    4) X^n
    5) H^n
    """
    circuit = cirq.Circuit()
    n = len(data_qubits)
    circuit.append(cirq.H.on_each(*data_qubits))
    circuit.append(cirq.X.on_each(*data_qubits))
    # multi-controlled Z on last data-qubit, controlled by the first (n-1)
    circuit.append(cirq.Z(data_qubits[-1]).controlled_by(*data_qubits[:-1]))
    circuit.append(cirq.X.on_each(*data_qubits))
    circuit.append(cirq.H.on_each(*data_qubits))
    return circuit

def run_grover_search_on_7qubits_with_ancilla(S_n, num_iterations=4, repetitions=1000):
    """
    8 qubits total:
      - data_qubits[0..6]: 7 for the search space
      - ancilla (qubit[7]): target of marking
    Steps:
      1) data_qubits -> uniform superposition
      2) ancilla -> |0> (unchanged)
      3) repeated marking + diffusion
      4) measure data_qubits (optionally also ancilla)
    Returns final circuit & histogram
    """
    # Create 8 line qubits: 7 data + 1 ancilla
    qubits = [cirq.LineQubit(i) for i in range(8)]
    data_qubits = qubits[:7]
    ancilla = qubits[7]
    
    circuit = cirq.Circuit()
    
    # Step 1: put only the data_qubits in uniform superposition
    circuit.append(cirq.H.on_each(*data_qubits))
    # The ancilla stays in |0>
    
    # Step 2: Grover iterations
    for _ in range(num_iterations):
        # Mark
        circuit += build_grover_marking(data_qubits, ancilla, S_n)
        # Diffuse
        circuit += build_grover_diffusion(data_qubits)
    
    # Step 3: measure data_qubits (and ancilla if you want)
    circuit.append(cirq.measure(*data_qubits, key='m_data'))
    circuit.append(cirq.measure(ancilla, key='m_ancilla'))
    
    sim = qsimcirq.QSimSimulator()
    result = sim.run(circuit, repetitions=repetitions)
    
    hist_data = result.histogram(key='m_data')
    hist_anc = result.histogram(key='m_ancilla')
    return circuit, hist_data, hist_anc


##########################################
#Deutsch-Josza Implimentation and Runs x 2

def classical_threshold_assignment(S_n, Sigma_T):
    """
    For each x in S_n: if x >= Sigma_T => 1, else => 0.
    Return a dict threshold_dict[x] = 0 or 1.
    """
    threshold_dict = {}
    for x in S_n:
        threshold_dict[x] = 1 if x >= Sigma_T else 0
    return threshold_dict

def build_deutsch_josza_oracle_7q(qubits, ancilla, S_n, threshold_dict, assign_complement):
    """
    7 data qubits + 1 ancilla:
      For x in [0..127]:
        if x in S_n => f(x) = threshold_dict[x],
        else => f(x) = assign_complement.
      If f(x)=1, flip ancilla's phase.
    """
    circuit = cirq.Circuit()
    n = len(qubits)  # should be 7
    def f(x):
        if x in threshold_dict:
            return threshold_dict[x]
        else:
            return assign_complement
    
    for x in range(2**n):
        if f(x) == 1:
            bin_str = format(x, '0{}b'.format(n))
            ops = []
            for i, bit in enumerate(bin_str):
                if bit == '0':
                    ops.append(cirq.X(qubits[i]))
            # multi-controlled Z on ancilla
            ops.append(cirq.Z(ancilla).controlled_by(*qubits))
            for i, bit in enumerate(bin_str):
                if bit == '0':
                    ops.append(cirq.X(qubits[i]))
            circuit.append(ops)
    return circuit

def run_deutsch_josza_7q(S_n, threshold_dict, assign_complement, reps=1024):
    """
    7 system qubits + 1 ancilla:
      1) ancilla -> |1>
      2) H on all 7 + ancilla
      3) Oracle
      4) H on all 7 + ancilla
      5) measure
    """
    qubits = [cirq.LineQubit(i) for i in range(7)]
    ancilla = cirq.LineQubit(7)
    circuit = cirq.Circuit()
    
    # 1) ancilla -> |1>
    circuit.append(cirq.X(ancilla))
    # 2) hadamard on all 7 + ancilla
    for q in qubits + [ancilla]:
        circuit.append(cirq.H(q))
    
    # 3) Oracle
    oracle_circ = build_deutsch_josza_oracle_7q(qubits, ancilla, S_n, threshold_dict, assign_complement)
    circuit += oracle_circ
    
    # 4) final H
    for q in qubits + [ancilla]:
        circuit.append(cirq.H(q))
    
    # 5) measure
    circuit.append(cirq.measure(*qubits, ancilla, key='m'))
    
    sim = qsimcirq.QSimSimulator()
    result = sim.run(circuit, repetitions=reps)
    counts = result.histogram(key='m')
    return circuit, counts


###########################################
#Main Script

def main():
    #----------------------------------------
    # 0) Suppose we have a "true" S_n
    #    Here just pick a few random states 
    #----------------------------------------
    S_n_true = [5, 12, 99, 100]  # 7-bit states that "occur" in our scenario
    print("=== EXAMPLE: S_n_true =", S_n_true, "===\n")
    
    #----------------------------------------
    # 1) RUN GROVER to identify these states
    #----------------------------------------
    grover_circ, hist_data, hist_anc = run_grover_search_on_7qubits_with_ancilla(
        S_n_true, 
        num_iterations=4, 
        repetitions=512
    )
    print("=== GROVER PHASE ===")
    print("Grover circuit:\n", grover_circ)
    
    print("\nGrover measurement (data) histogram:")
    print(hist_data)
    print("\nGrover ancilla measurement histogram:")
    print(hist_anc)
    print("\n(Interpretation: states in S_n_true are hopefully amplified in 'm_data'.)\n")
    
    # For simplicity, we assume we "read off" from hist_data that 
    # S_n_inferred = S_n_true
    
    S_n_inferred = S_n_true[:]
    
    #----------------------------------------
    # 2) Decide threshold and do classical assignment
    #----------------------------------------
    Sigma_T = 50
    threshold_dict = classical_threshold_assignment(S_n_inferred, Sigma_T)
    print("Threshold dict (x >= 50 => 1, else 0):")
    print(threshold_dict, "\n")
    
    #----------------------------------------
    # 3) DEUTSCHâ€“JOSZA RUNS
    #----------------------------------------
    
    # (a) assign_complement = 0
    circ1, counts1 = run_deutsch_josza_7q(S_n_inferred, threshold_dict, assign_complement=0, reps=512)
    print("=== DEUTSCH-JOSZA RUN 1 (S_n^c => 0) ===")
    print("Circuit 1:\n", circ1)
    print("Measurement histogram (decimal):", counts1)
    print()
    
    # (b) assign_complement = 1
    circ2, counts2 = run_deutsch_josza_7q(S_n_inferred, threshold_dict, assign_complement=1, reps=512)
    print("=== DEUTSCH-JOSZA RUN 2 (S_n^c => 1) ===")
    print("Circuit 2:\n", circ2)
    print("Measurement histogram (decimal):", counts2)
    print()
    
    print("Done.")

if __name__ == "__main__":
    main()
